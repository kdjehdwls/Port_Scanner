# 멀티스레딩과 비동기식프로그래밍의 모든 것

### **멀티스레딩 (Multithreading)**

- "멀티스레딩"이라는 용어는 "멀티(Multi)"와 "스레딩(Threading)"의 결합으로, 여러 "스레드"가 동시에 실행되는 것을 의미합니다. "스레드"는 실행 흐름의 가장 작은 단위로, 기본적으로 프로그램 내에서 동시에 여러 작업을 수행할 수 있게 하는 경량 프로세스입니다.
- **역사**: 멀티스레딩의 개념은 1960년대 초반의 시분할 시스템과 함께 등장했습니다. 초기의 컴퓨터 시스템은 한 번에 하나의 작업만 수행할 수 있었지만, 시분할 시스템의 도입으로 여러 사용자가 컴퓨터 리소스를 공유하고 동시에 작업을 수행할 수 있게 되었습니다. 멀티스레딩은 이러한 개념을 한 단계 발전시켜, 단일 프로그램 내에서도 동시에 여러 작업을 수행할 수 있게 만들었습니다. (1960년대에 여러 연구 기관과 대학에서 동시에 연구되고 개발. 예를 들어, MIT, GE, Bell Labs의 연구원들이 협력하여 개발한 Multics(멀틱스) 운영 체제는 시분할 시스템과 멀티태스킹 개념의 초기 예)

### **비동기식 프로그래밍 (Asynchronous Programming)**

- "비동기식"이라는 용어는 "비(非)"와 "동기식(同期式)"의 결합으로, 작업들이 시작되는 시점이 서로 동기화되지 않음을 의미합니다. 이는 한 작업이 완료될 때까지 기다리지 않고 다른 작업을 시작할 수 있음을 뜻합니다.
- **역사**: 비동기식 프로그래밍의 기원은 멀티태스킹과 밀접한 관련이 있습니다. 멀티태스킹이 발전하면서, 프로그램이 여러 작업을 동시에 처리할 필요성이 생겼고, 이에 따라 비동기식 프로그래밍 모델이 발전했습니다. 1970년대와 1980년대의 네트워킹과 이벤트 주도 프로그래밍의 발전은 비동기식 프로그래밍의 중요한 촉진제였습니다. 이러한 모델은 프로그램이 네트워크 요청이나 사용자 입력과 같은 이벤트를 기다리는 동안 다른 작업을 계속할 수 있게 해줍니다. (비동기 프로그래밍은 사용자 인터페이스, 네트워킹, I/O 작업과 같이 응답성이 중요한 시스템에서 사용자의 입력이나 외부 이벤트에 빠르게 반응해야 할 필요성에서 자연스럽게 발전. 이러한 요구사항은 컴퓨터의 초기 시절부터 존재했으며, 시간이 지나면서 이벤트 기반 프로그래밍, 콜백 함수, 프로미스, async/await와 같은 비동기 프로그래밍 패턴이 개발)

### **공통점과 차이점**

멀티스레딩과 비동기식 프로그래밍 모두 프로그램의 성능을 향상시키고 리소스를 더 효율적으로 사용할 수 있게 해줍니다. 그러나 멀티스레딩은 동시에 여러 작업을 수행하기 위해 여러 스레드를 사용하는 반면, 비동기식 프로그래밍은 단일 스레드 내에서 작업의 실행 순서를 조정하여 비동기적 작업을 가능하게 합니다.

간단하게 말하자면, 둘다 리소스 효율을 위해 사용하고 차이점은 멀티스레딩은 말그대로 여러 스레드, 비동기식 프로그래밍은 단일 스레드 라는 것.

# 하드웨어적 의미와 소프트웨어적 의미

### 멀티스레딩

**하드웨어적 스레드**는 CPU 내의 물리적 또는 논리적 실행 단위를 의미합니다. 예를 들어, 멀티코어 프로세서에서 각 코어는 동시에 여러 스레드를 처리할 수 있는 능력을 가질 수 있습니다. 이는 '동시 멀티스레딩(Simultaneous Multithreading, SMT)' 기술에 의해 가능해지며, 인텔의 하이퍼스레딩(Hyper-Threading)이 대표적인 예입니다. 하드웨어적 스레드는 CPU가 동시에 여러 명령어 스트림을 처리할 수 있게 해주어 프로그램의 실행 성능을 향상시킬 수 있습니다.

**소프트웨어적 스레드**는 운영 체제가 관리하는 프로세스 내의 실행 경로 또는 실행 단위를 의미합니다. 소프트웨어 개발에서 멀티스레딩은 하나의 애플리케이션이나 프로세스 내에서 동시에 여러 작업을 수행할 수 있도록 하는 기술입니다. 소프트웨어적 스레드는 운영 체제의 스케줄러에 의해 CPU 시간을 할당받아 실행되며, 개발자는 이를 통해 병렬 처리와 작업 분할을 구현할 수 있습니다.

하드웨어적 스레드와 소프트웨어적 스레드는 서로 **상호작용**합니다. 운영 체제는 소프트웨어적 스레드를 스케줄링하여 하드웨어적 스레드에 할당합니다. 이 과정에서 멀티스레딩을 지원하는 CPU는 동시에 여러 소프트웨어적 스레드를 실행할 수 있게 해주어 전반적인 시스템의 성능과 반응성을 향상시킬 수 있습니다.

따라서 멀티스레딩을 논할 때는 이 두 가지 측면을 모두 고려해야 합니다. 소프트웨어적 멀티스레딩은 프로그램의 구조와 설계에 관련되며, 하드웨어적 멀티스레딩은 이러한 소프트웨어 스레드들이 실제로 CPU에서 어떻게 실행되는지에 영향을 줍니다.

---

**비동기식 프로그래밍**

**하드웨어적 관점**에서 비동기식 동작은 하드웨어 컴포넌트들이 클록 신호나 다른 동기화 메커니즘 없이 독립적으로 작동하는 것을 의미합니다. 예를 들어, 비동기식 통신에서는 데이터 전송이 특정한 클록 신호에 의존하지 않고, 데이터 자체 또는 별도의 신호에 의해 전송의 시작과 끝이 결정됩니다. 이러한 방식은 하드웨어 디자인에서 타이밍 이슈를 줄이고, 다양한 속도로 작동하는 컴포넌트 간의 통신을 용이하게 합니다.

**소프트웨어적 관점**에서 비동기식 프로그래밍은 프로그램의 주 실행 흐름이 작업의 완료를 기다리지 않고 즉시 다음 작업으로 넘어가는 방식을 의미합니다. 비동기 작업은 대개 I/O 작업, 네트워크 요청, 파일 시스템 작업 등과 같이 완료되는 데 시간이 걸리는 작업에 사용됩니다. 비동기식 프로그래밍에서는 작업이 완료되면 콜백 함수가 호출되거나 프로미스가 처리되어 결과를 반환합니다. 이러한 방식은 프로그램이 효율적으로 멀티태스킹을 수행하고, 리소스를 최적화하며, 사용자 인터페이스의 응답성을 유지하는 데 도움이 됩니다.

**상호작용**

하드웨어와 소프트웨어의 비동기식 동작은 서로 다른 레벨에서 동작하지만, 효율적인 시스템 설계에서 중요한 역할을 합니다. 예를 들어, 하드웨어의 비동기식 통신 메커니즘은 소프트웨어의 비동기 프로그래밍 모델을 지원하고 최적화하는 데 사용될 수 있습니다. 반대로, 소프트웨어의 비동기식 설계는 하드웨어 리소스의 비효율적인 사용을 방지하고, 시스템의 전반적인 성능과 응답성을 향상시킬 수 있습니다.

### 개인적인 궁금증. 단일 스레드인데 어떻게 비동기적으로 프로그래밍 되는걸까?

비동기식 프로그래밍이 단일 스레드에서 작동할 수 있는 방식은 이벤트 루프와 비동기 작업의 스케줄링 방식 덕분입니다. 이러한 방식은 주로 자바스크립트와 같은 언어에서 볼 수 있는데, Node.js의 이벤트 기반 모델이 좋은 예입니다. 비동기 프로그래밍 모델에서는 단일 스레드가 이벤트 루프를 사용하여 여러 비동기 작업을 효율적으로 처리할 수 있습니다.

### **이벤트 루프와 비동기 작업의 핵심 개념:**

1. **이벤트 루프(Event Loop)**:
    - 이벤트 루프는 프로그램의 실행 흐름을 제어하는 루프로, 발생하는 이벤트나 작업들을 관리하고 실행합니다.
    - 이벤트 루프는 실행할 작업이 있는지 지속적으로 확인하고, 실행할 작업이 있을 때 해당 작업을 실행합니다.
2. **비동기 작업**:
    - 비동기 작업은 파일 읽기/쓰기, 네트워크 요청, 데이터베이스 쿼리 등의 작업을 포함할 수 있으며, 이러한 작업들은 보통 완료되는 데 시간이 걸립니다.
    - 비동기 작업은 작업을 요청한 후 결과를 기다리지 않고 바로 다음 작업으로 넘어갈 수 있게 합니다. 작업의 완료나 결과는 콜백 함수, 프로미스(Promises), async/await와 같은 메커니즘을 통해 처리됩니다.
3. **작업의 분할**:
    - 비동기 프로그래밍에서는 복잡한 작업을 여러 개의 작은 비동기 작업으로 분할할 수 있습니다. 이렇게 하면 각 비동기 작업이 독립적으로 스케줄되어 이벤트 루프를 통해 관리됩니다.
    - 예를 들어, 파일을 여러 부분으로 나누어 비동기적으로 읽거나, 여러 네트워크 요청을 동시에 보내고 각각의 응답을 비동기적으로 처리할 수 있습니다.

### **예시: Node.js에서의 비동기 프로그래밍**

Node.js는 비동기 이벤트 주도 아키텍처를 사용하여 단일 스레드에서 효율적으로 여러 I/O 작업을 처리할 수 있습니다. Node.js의 비동기 API는 작업이 완료될 때까지 기다리지 않고 즉시 반환되며, 작업 완료 시 콜백 함수가 호출됩니다. 이를 통해 Node.js 애플리케이션은 I/O 작업을 기다리는 동안 다른 작업을 계속 처리할 수 있으며, 이는 높은 동시성과 성능 향상을 가능하게 합니다.

**단일 스레드 내라면, 비동기 프로그래밍의 단위는?** 

비동기식 프로그래밍에서는 "작업"이나 "태스크" 단위를 사용하여 프로그램을 구성합니다. 이러한 작업들은 전통적인 스레드 기반의 멀티태스킹과는 다르게 동작합니다. 비동기 작업은 I/O 작업, 타이머, 네트워크 요청 등이 완료되기를 기다리는 동안 메인 스레드를 차단하지 않고, 작업 완료 시 콜백 함수나 프로미스(resolve/reject)를 통해 결과를 처리합니다.

**단일 스레드이지만 동시성을 띠는 것처럼 보이는 이유!**

- **비동기 작업의 동시성**: 비동기 프로그래밍 모델에서는 여러 비동기 작업이 동시에 "실행"되는 것처럼 보일 수 있습니다. 실제로는 이러한 작업들이 백그라운드에서 동시에 처리되거나, 메인 스레드에서 순차적으로 결과를 처리하는 방식으로 동시성이 구현됩니다.
- **이벤트와 콜백 큐**: 이벤트 루프는 이벤트나 콜백이 발생할 때마다 이를 큐에 추가합니다. 메인 스레드는 이 큐를 순차적으로 처리하며, 한 작업이 처리되는 동안 다른 작업을 차단하지 않습니다.

**아하! 같이 사용하면 더 좋은 방식 이겠군**

멀티스레딩과 비동기식 프로그래밍을 함께 사용하는 것은 매우 효율적인 프로그래밍 패러다임 중 하나입니다. 이러한 접근 방식은 복잡한 애플리케이션과 시스템, 특히 고성능이 요구되는 서버 애플리케이션, 대규모 데이터 처리, 실시간 서비스 등에서 널리 사용됩니다. 멀티스레딩과 비동기 프로그래밍의 결합은 다음과 같은 이점을 제공합니다:

### **이점**

1. **성능 향상**: 멀티스레딩을 사용하면 여러 CPU 코어를 활용하여 병렬 처리가 가능해집니다. 각 스레드가 비동기식으로 작동하면 I/O 블로킹이 감소하고, CPU 사용률이 최적화되어 전체적인 애플리케이션 성능이 향상됩니다.
2. **응답성 향상**: 애플리케이션이 사용자 입력, 네트워크 요청 등 외부 이벤트에 빠르게 반응해야 하는 경우, 비동기 프로그래밍은 이벤트 처리 시 메인 스레드를 차단하지 않고 다른 작업을 계속 진행할 수 있게 합니다. 멀티스레딩과 결합하면 더 많은 작업을 동시에 처리할 수 있습니다.
3. **리소스 활용 최적화**: 멀티스레딩은 CPU 리소스를 활용하는 반면, 비동기 프로그래밍은 I/O 작업이 스레드를 차단하지 않도록 함으로써 I/O 리소스를 효율적으로 사용합니다. 이 두 방식을 조합하면 CPU와 I/O 리소스 모두를 효율적으로 사용할 수 있습니다.

### **고려사항**

- **복잡성 관리**: 멀티스레딩과 비동기 프로그래밍을 결합하면 코드의 복잡성이 증가할 수 있습니다. 올바른 동기화, 데드락 회피, 콜백 지옥 해결 등 추가적인 설계 고려사항이 필요합니다.
- **디버깅과 유지보수**: 병렬 처리와 비동기 작업의 결합은 디버깅과 유지보수를 어렵게 만들 수 있습니다. 코드의 실행 순서가 직관적이지 않고, 예상치 못한 상태와 경쟁 조건이 발생할 수 있습니다.
- **적절한 사용**: 모든 경우에 멀티스레딩과 비동기 프로그래밍을 함께 사용하는 것이 최선은 아닙니다. 애플리케이션의 요구사항, 성능 목표, 리소스 제약 조건 등을 고려하여 적절한 아키텍처를 선택해야 합니다.

멀티스레딩과 비동기 프로그래밍의 결합은 강력한 도구이지만, 이를 효과적으로 사용하기 위해서는 세심한 설계와 테스트가 필요합니다. 이를 통해 성능, 확장성, 응답성이 뛰어난 애플리케이션을 구축할 수 있습니다.

# 코드로 구현해보기

### **멀티스레딩 예시**

멀티스레딩 예시에서는 **`threading`** 모듈을 사용하여 간단한 작업을 동시에 수행하는 스레드를 생성합니다.

```python

import threading
import time

def print_numbers():
    for i in range(1, 6):
        time.sleep(1)
        print(f"Number {i}")

def print_letters():
    for letter in 'abcde':
        time.sleep(1.5)
        print(f"Letter {letter}")

# 스레드 생성 및 시작
thread1 = threading.Thread(target=print_numbers)
thread2 = threading.Thread(target=print_letters)

thread1.start()
thread2.start()

# 스레드가 완료될 때까지 기다림
thread1.join()
thread2.join()

print("멀티스레딩 예시 완료")

```

### **비동기식 프로그래밍 예시**

비동기식 프로그래밍 예시에서는 **`asyncio`** 모듈을 사용하여 비동기적으로 작업을 수행합니다.

```python

import asyncio

async def count_to_five():
    for i in range(1, 6):
        await asyncio.sleep(1)
        print(f"Async Number {i}")

async def count_letters():
    for letter in 'abcde':
        await asyncio.sleep(1.5)
        print(f"Async Letter {letter}")

async def main():
    # 두 비동기 작업 동시 실행
    await asyncio.gather(count_to_five(), count_letters())

# 이벤트 루프 실행
asyncio.run(main())

print("비동기식 프로그래밍 예시 완료")

```

### 멀티스레딩과 비동기식 프로그래밍을 동시에?

멀티스레딩과 비동기식 프로그래밍을 함께 사용하는 예시로는 **웹 서버**가 있습니다. 고성능 웹 서버는 동시에 많은 요청을 처리할 수 있어야 하며, 이를 위해 멀티스레딩과 비동기식 I/O를 결합하여 사용합니다. 이러한 접근 방식은 서버의 처리량을 최대화하고, 리소스 사용을 최적화하며, 응답 시간을 줄이는 데 도움이 됩니다.

다음은 멀티스레딩과 비동기식 프로그래밍을 함께 사용하는 간단한 웹 서버 예시입니다. 이 예제에서는 파이썬의 **`asyncio`**와 **`aiohttp`** 라이브러리를 사용하여 비동기식 웹 서버를 구현하고, **`concurrent.futures.ThreadPoolExecutor`**를 사용하여 CPU 집약적 작업을 별도의 스레드에서 처리합니다.

```python

import asyncio
from aiohttp import web
import time
from concurrent.futures import ThreadPoolExecutor

# CPU 집약적 작업을 수행하는 함수
def cpu_bound_task(n):
    print(f"CPU-bound task 시작: {n}")
    time.sleep(n)  # 대기 시간으로 CPU 작업을 시뮬레이션
    print(f"CPU-bound task 완료: {n}")
    return f"Task {n} 완료"

# 비동기 핸들러 함수
async def handle(request):
    n = int(request.match_info.get('n', 1))

    # 비동기적으로 CPU 집약적 작업을 스레드 풀에서 실행
    loop = asyncio.get_event_loop()
    result = await loop.run_in_executor(executor, cpu_bound_task, n)

    return web.Response(text=result)

# 웹 서버 애플리케이션 생성
app = web.Application()
app.add_routes([web.get('/{n}', handle)])

# 스레드 풀 실행자 생성
executor = ThreadPoolExecutor(max_workers=4)

# 웹 서버 실행
web.run_app(app, port=8080)

```

이 예제에서는 **`/n`** 경로로 들어오는 요청을 처리하며, URL의 **`n`** 부분을 추출하여 **`cpu_bound_task`** 함수에 전달합니다. 이 함수는 스레드 풀에서 비동기적으로 실행되므로, 메인 이벤트 루프는 다른 HTTP 요청을 계속 처리할 수 있습니다. **`cpu_bound_task`** 함수는 CPU 집약적 작업을 시뮬레이션하기 위해 일부러 시간 지연을 사용합니다.

이러한 방식으로 멀티스레딩과 비동기식 프로그래밍을 결합하면, I/O 바운드 작업(예: 클라이언트 요청 처리)과 CPU 바운드 작업(예: 데이터 처리)을 효율적으로 동시에 처리할 수 있습니다. 이는 특히 동시에 많은 요청을 처리해야 하는 웹 서버와 같은 애플리케이션에 유용합니다.
